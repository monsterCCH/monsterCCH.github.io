#Googletest入门

##简介：为什么选择googletest？

*googletest*可帮助您编写更好的C ++测试。

googletest是由测试技术团队根据Google的特定要求和约束开发的测试框架。无论您是在Linux，Windows还是Mac上工作，如果您编写C ++代码，googletest都可以为您提供帮助。它支持任何类型的测试，而不仅仅是单元测试。

那么什么才是一个好的测试，以及googletest如何适合呢？我们相信：

1. 测试应独立且可重复。调试由于其他测试而成功或失败的测试是很痛苦的。googletest通过在不同的对象上运行每个测试来隔离测试，如果测试失败，则googletest允许您单独运行它以进行快速调试。
2. 测试应该井井有条，并能反映出测试代码的结构。googletest将相关测试分组到可以共享数据和子例程的测试套件中。这种常见的模式易于识别，并使测试易于维护。当人们切换项目并开始在新的代码库上工作时，这种一致性特别有用。
3. 测试应该是可移植且可重复使用的。Google有很多与平台无关的代码，其测试也应该与平台无关。googletest可在不同的操作系统，不同的编译器上运行，无论有无例外，因此googletest测试可以在多种配置下运行。
4. 如果测试失败，则应提供有关该问题的尽可能多的信息。googletest不会在第一次测试失败时停止。相反，它只会停止当前测试并继续进行下一个测试。您还可以设置报告非致命故障的测试，然后继续当前测试。因此，您可以在一个运行编辑编辑循环中检测并修复多个错误。
5. 测试框架应使测试编写者摆脱内部管理的繁琐工作，并使他们专注于测试内容。googletest自动跟踪定义的所有测试，并且不需要用户枚举即可运行它们。
6. 测试应该很快。使用googletest，您可以在测试之间重用共享资源，并且只需消耗一次资源，而无需使测试相互依赖。

由于googletest基于流行的xUnit架构，因此如果您以前使用过JUnit或PyUnit，就会感到宾至如归。如果没有，那么大约需要10分钟来学习基础知识并开始使用。所以走吧!

##小心混淆术语

>注意：术语Test，Test Case和Test Suite的不同定义可能会引起混淆，因此请注意不要混淆它们。

注意：术语Test，Test Case和Test Suite的不同定义可能会引起混淆，因此请注意不要混淆它们。

从历史上看，googletest开始使用“测试用例”一词来对相关测试进行分组，而当前的出版物（包括国际软件测试资格委员会（ISTQB）资料和各种有关软件质量的教科书）都使用了“测试套件”一词 。

googletest中使用的相关术语Test（测试）与ISTQB及其它测试术语（Test Case）相对应 。

“测试”一词通常具有足够广泛的含义，包括ISTQB的“测试用例”的定义，因此在这里并没有太大的问题。但长期测试案例如在谷歌测试使用的是矛盾的感觉，从而混淆。

googletest最近开始用术语测试用例与测试套件。首选的API是TestSuite。较旧的TestCase API逐渐被弃用并重构。

因此，请注意这些术语的不同定义：

|           含义                | googletest 条款 | ISTQB 术语 |
| ------------------------------------- | ------ | ---------- |
| 使用特定的输入值来执行特定的程序路径并验证结果 | TEST() | 	Test Case | 

##基本概念

当使用googletest，通过编写启动断言检查是否条件为真。断言的结果可能是成功（success）， 非致命失败（nonfatal）或致命失败（fatal）。如果发生致命故障，它将中止当前功能。否则程序将继续正常运行。

测试使用断言来验证被测试代码的行为。如果测试崩溃或断言失败，则它失败，否则成功。

一个测试套件包含一个或多个测试，您应该将测试分为反映套件代码结构的测试套件。当测试套件中的多个测试需要共享通用对象和子例程时，可以将它们放入测试fixture类。

一个测试程序可以包含多个测试套件。

现在，我们将说明如何编写测试程序，该程序从各个声明级别开始，直至构建测试和测试套件

##断言

googletest断言是类似于函数调用的宏。您可以通过对类或函数的行为进行断言来测试它。断言失败时，googletest会输出断言的源文件和行号位置以及失败消息。您还可以提供自定义失败消息，该消息将附加到googletest的消息中。

断言成对出现，测试相同的事物，但对当前函数有不同的影响。ASSERT_*版本失败时会产生致命错误，并中止当前功能。EXPECT_*版本会产生非致命故障，不会导致当前功能中断。通常EXPECT_*是首选，因为它们允许在测试中报告多个故障。但是，ASSERT_*如果在断言失败时继续执行没有意义，则应使用。

由于失败会ASSERT_*立即从当前函数返回，可能会跳过其后的清除代码，因此可能会导致空间泄漏。根据泄漏的性质，它可能不值得修复，因此请牢记这一点，如果您除了断言错误之外还遇到堆检查器错误。

要提供自定义失败消息，只需使用<<运算符或此类运算符的序列将其流式传输到宏中即可 。一个例子：

```C++
ASSERT_EQ(x.size(), y.size()) << "Vectors x and y are of unequal length";

for (int i = 0; i < x.size(); ++i) {
  EXPECT_EQ(x[i], y[i]) << "Vectors x and y differ at index " << i;
}
```
任何内容都可以放到ostream流，尤其是C字符串和string对象。如果将宽字符串（wchar_t*，TCHAR*在UNICODEWindows上为模式，或std::wstring）流式传输到声明，则在打印时将其转换为UTF-8。

##基本断言
这些断言进行基本的真/假条件测试。
